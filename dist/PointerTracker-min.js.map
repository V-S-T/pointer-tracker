{"version":3,"file":"PointerTracker-min.js","sources":["PointerTracker.mjs"],"sourcesContent":["class Pointer {\n    constructor(nativePointer) {\n        /** Unique ID for this pointer */\n        this.id = -1;\n        this.nativePointer = nativePointer;\n        this.pageX = nativePointer.pageX;\n        this.pageY = nativePointer.pageY;\n        this.clientX = nativePointer.clientX;\n        this.clientY = nativePointer.clientY;\n        if (self.Touch && nativePointer instanceof Touch) {\n            this.id = nativePointer.identifier;\n        }\n        else if (isPointerEvent(nativePointer)) {\n            // is PointerEvent\n            this.id = nativePointer.pointerId;\n        }\n    }\n    /**\n     * Returns an expanded set of Pointers for high-resolution inputs.\n     */\n    getCoalesced() {\n        if ('getCoalescedEvents' in this.nativePointer) {\n            const events = this.nativePointer\n                .getCoalescedEvents()\n                .map((p) => new Pointer(p));\n            // Firefox sometimes returns an empty list here. I'm not sure it's doing the right thing.\n            // https://github.com/w3c/pointerevents/issues/409\n            if (events.length > 0)\n                return events;\n            // Otherwise, Firefox falls throughâ€¦\n        }\n        return [this];\n    }\n}\nconst isPointerEvent = (event) => 'pointerId' in event;\nconst isTouchEvent = (event) => 'changedTouches' in event;\nconst noop = () => { };\n/**\n * Track pointers across a particular element\n */\nclass PointerTracker {\n    /**\n     * Track pointers across a particular element\n     *\n     * @param element Element to monitor.\n     * @param options\n     */\n    constructor(_element, { start = () => true, move = noop, end = noop, rawUpdates = false, avoidPointerEvents = false, } = {}) {\n        this._element = _element;\n        /**\n         * State of the tracked pointers when they were pressed/touched.\n         */\n        this.startPointers = [];\n        /**\n         * Latest state of the tracked pointers. Contains the same number of pointers, and in the same\n         * order as this.startPointers.\n         */\n        this.currentPointers = [];\n        /**\n         * Firefox has a bug where touch-based pointer events have a `buttons` of 0, when this shouldn't\n         * happen. https://bugzilla.mozilla.org/show_bug.cgi?id=1729440\n         *\n         * Usually we treat `buttons === 0` as no-longer-pressed. This set allows us to exclude these\n         * buggy Firefox events.\n         */\n        this._excludeFromButtonsCheck = new Set();\n        /**\n         * Listener for mouse/pointer starts.\n         *\n         * @param event This will only be a MouseEvent if the browser doesn't support pointer events.\n         */\n        this._pointerStart = (event) => {\n            if (isPointerEvent(event) && event.buttons === 0) {\n                // This is the buggy Firefox case. See _excludeFromButtonsCheck.\n                this._excludeFromButtonsCheck.add(event.pointerId);\n            }\n            else if (!(event.buttons & 1 /* LeftMouseOrTouchOrPenDown */)) {\n                return;\n            }\n            const pointer = new Pointer(event);\n            // If we're already tracking this pointer, ignore this event.\n            // This happens with mouse events when multiple buttons are pressed.\n            if (this.currentPointers.some((p) => p.id === pointer.id))\n                return;\n            if (!this._triggerPointerStart(pointer, event))\n                return;\n            // Add listeners for additional events.\n            // The listeners may already exist, but no harm in adding them again.\n            if (isPointerEvent(event)) {\n                const capturingElement = event.target && 'setPointerCapture' in event.target\n                    ? event.target\n                    : this._element;\n                capturingElement.setPointerCapture(event.pointerId);\n                this._element.addEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\n                this._element.addEventListener('pointerup', this._pointerEnd);\n                this._element.addEventListener('pointercancel', this._pointerEnd);\n            }\n            else {\n                // MouseEvent\n                window.addEventListener('mousemove', this._move);\n                window.addEventListener('mouseup', this._pointerEnd);\n            }\n        };\n        /**\n         * Listener for touchstart.\n         * Only used if the browser doesn't support pointer events.\n         */\n        this._touchStart = (event) => {\n            for (const touch of Array.from(event.changedTouches)) {\n                this._triggerPointerStart(new Pointer(touch), event);\n            }\n        };\n        /**\n         * Listener for pointer/mouse/touch move events.\n         */\n        this._move = (event) => {\n            if (!isTouchEvent(event) &&\n                (!isPointerEvent(event) ||\n                    !this._excludeFromButtonsCheck.has(event.pointerId)) &&\n                event.buttons === 0 /* None */) {\n                // This happens in a number of buggy cases where the browser failed to deliver a pointerup\n                // or pointercancel. If we see the pointer moving without any buttons down, synthesize an end.\n                // https://github.com/w3c/pointerevents/issues/407\n                // https://github.com/w3c/pointerevents/issues/408\n                this._pointerEnd(event);\n                return;\n            }\n            const previousPointers = this.currentPointers.slice();\n            const changedPointers = isTouchEvent(event)\n                ? Array.from(event.changedTouches).map((t) => new Pointer(t))\n                : [new Pointer(event)];\n            const trackedChangedPointers = [];\n            for (const pointer of changedPointers) {\n                const index = this.currentPointers.findIndex((p) => p.id === pointer.id);\n                if (index === -1)\n                    continue; // Not a pointer we're tracking\n                trackedChangedPointers.push(pointer);\n                this.currentPointers[index] = pointer;\n            }\n            if (trackedChangedPointers.length === 0)\n                return;\n            this._moveCallback(previousPointers, trackedChangedPointers, event);\n        };\n        /**\n         * Call the end callback for this pointer.\n         *\n         * @param pointer Pointer\n         * @param event Related event\n         */\n        this._triggerPointerEnd = (pointer, event) => {\n            // Main button still down?\n            // With mouse events, you get a mouseup per mouse button, so the left button might still be down.\n            if (!isTouchEvent(event) &&\n                event.buttons & 1 /* LeftMouseOrTouchOrPenDown */) {\n                return false;\n            }\n            const index = this.currentPointers.findIndex((p) => p.id === pointer.id);\n            // Not a pointer we're interested in?\n            if (index === -1)\n                return false;\n            this.currentPointers.splice(index, 1);\n            this.startPointers.splice(index, 1);\n            this._excludeFromButtonsCheck.delete(pointer.id);\n            // The event.type might be a 'move' event due to workarounds for weird mouse behaviour.\n            // See _move for details.\n            const cancelled = !(event.type === 'mouseup' ||\n                event.type === 'touchend' ||\n                event.type === 'pointerup');\n            this._endCallback(pointer, event, cancelled);\n            return true;\n        };\n        /**\n         * Listener for mouse/pointer ends.\n         *\n         * @param event This will only be a MouseEvent if the browser doesn't support pointer events.\n         */\n        this._pointerEnd = (event) => {\n            if (!this._triggerPointerEnd(new Pointer(event), event))\n                return;\n            if (isPointerEvent(event)) {\n                if (this.currentPointers.length)\n                    return;\n                this._element.removeEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\n                this._element.removeEventListener('pointerup', this._pointerEnd);\n                this._element.removeEventListener('pointercancel', this._pointerEnd);\n            }\n            else {\n                // MouseEvent\n                window.removeEventListener('mousemove', this._move);\n                window.removeEventListener('mouseup', this._pointerEnd);\n            }\n        };\n        /**\n         * Listener for touchend.\n         * Only used if the browser doesn't support pointer events.\n         */\n        this._touchEnd = (event) => {\n            for (const touch of Array.from(event.changedTouches)) {\n                this._triggerPointerEnd(new Pointer(touch), event);\n            }\n        };\n        this._startCallback = start;\n        this._moveCallback = move;\n        this._endCallback = end;\n        this._rawUpdates = rawUpdates && 'onpointerrawupdate' in window;\n        // Add listeners\n        if (self.PointerEvent && !avoidPointerEvents) {\n            this._element.addEventListener('pointerdown', this._pointerStart);\n        }\n        else {\n            this._element.addEventListener('mousedown', this._pointerStart);\n            this._element.addEventListener('touchstart', this._touchStart);\n            this._element.addEventListener('touchmove', this._move);\n            this._element.addEventListener('touchend', this._touchEnd);\n            this._element.addEventListener('touchcancel', this._touchEnd);\n        }\n    }\n    /**\n     * Remove all listeners.\n     */\n    stop() {\n        this._element.removeEventListener('pointerdown', this._pointerStart);\n        this._element.removeEventListener('mousedown', this._pointerStart);\n        this._element.removeEventListener('touchstart', this._touchStart);\n        this._element.removeEventListener('touchmove', this._move);\n        this._element.removeEventListener('touchend', this._touchEnd);\n        this._element.removeEventListener('touchcancel', this._touchEnd);\n        this._element.removeEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\n        this._element.removeEventListener('pointerup', this._pointerEnd);\n        this._element.removeEventListener('pointercancel', this._pointerEnd);\n        window.removeEventListener('mousemove', this._move);\n        window.removeEventListener('mouseup', this._pointerEnd);\n    }\n    /**\n     * Call the start callback for this pointer, and track it if the user wants.\n     *\n     * @param pointer Pointer\n     * @param event Related event\n     * @returns Whether the pointer is being tracked.\n     */\n    _triggerPointerStart(pointer, event) {\n        if (!this._startCallback(pointer, event))\n            return false;\n        this.currentPointers.push(pointer);\n        this.startPointers.push(pointer);\n        return true;\n    }\n}\n\nexport { PointerTracker as default };\n//# sourceMappingURL=PointerTracker.mjs.map\n"],"names":["Pointer","[object Object]","nativePointer","this","id","pageX","pageY","clientX","clientY","self","Touch","identifier","isPointerEvent","pointerId","events","getCoalescedEvents","map","p","length","event","isTouchEvent","noop","_element","start","move","end","rawUpdates","avoidPointerEvents","startPointers","currentPointers","_excludeFromButtonsCheck","Set","_pointerStart","buttons","add","pointer","some","_triggerPointerStart","target","setPointerCapture","addEventListener","_rawUpdates","_move","_pointerEnd","window","_touchStart","touch","Array","from","changedTouches","has","previousPointers","slice","changedPointers","t","trackedChangedPointers","index","findIndex","push","_moveCallback","_triggerPointerEnd","splice","delete","cancelled","type","_endCallback","removeEventListener","_touchEnd","_startCallback","PointerEvent"],"mappings":"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"}